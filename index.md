## به نام خداوند بخشنده مهربان

### Python MRO
#### توضیحات کلی
در پایتون الگوریتم
MRO 
 یا 
(Method Resolution Order)
مسیر جست و جوی کلاس‌ها برای یافتن تابع درست به منظور به کارگیری در هنگام صدازدن تابع کلاس‌ها در ارث‌بری چندگانه را تعیین می‌کند.

این الگوریتم در پایتون ۲.۲ به ۲.۳ تغییراتی کرده است و به منظور نگهداری سازگاری برای استفاده از آن در پایتون ۲.۳ به بعد می بایست تا از کلاس
object 
ارث‌بری انجام شود. اما در پایتون ۳ به طور پیش‌فرض از الگوریتم جدید استفاده می‌شود.

برای مثال در کد زیر مسیری که
MRO 
تعیین می کند با استفاده از الگوریتم قدیمی
است.

```markdown

class A :
    pass
class B :
    pass
class C(A, B) :
    pass
    
```
اما اگر در پایتون ۲.۳ به بعد به صورت زیر به کار رود از الگوریتم جدید استفاده می‌کند:
```markdown
class A(object) :
    pass
class B(object) :
    pass
```

### توضیح الگوریتم قدیمی
با مثال زیر آغاز می‌کنیم:
```markdown
class A:
    def who_am_i(self):
        print("I am a A")

class B(A):
    def who_am_i(self):
        print("I am a B")

class C(A):
    def who_am_i(self):
        print("I am a C")

class D(B,C):
    def who_am_i(self):
        print("I am a D")

d1 = D()
d1.who_am_i()
```
پس از اجرای کد بالا در پایتون ۲ خواهیم داشت:

```markdown
$ python2 Python-MRO.py  
I am a D
```
پس از کامنت‌کردن کد 
D خواهیم داشت:

```markdown
class D(B,C):
\#    def who_am_i(self):
\#        print("I am a D")
    pass
```

اکنون خروجی کد به صورت زیر خواهد بود:

```markdown
$ python2 Python-MRO.py  
I am a B
```

در توضیح باید گفت که الگوریتم به صورت 
DFS
در گرافی که از ارث‌بری‌ها به وجود می‌آید عمل می‌کند و ترتیب در هر سطر از چپ به راست است.
لذا پس از حذف تابع از 
D
باید شاهد آن باشیم تا تابع 
B
صدا شود.

### توضیح الگوریتم جدید
در الگوریتم جدید تغییراتی در روند پرمایش گراف ارث‌بری به وجود آمده که باعث می‌شود ترتیب جست‌وجو برای پیدا کردن تابع موردنظر تغییر یابد.

تابعی که ترتیب جدید را به دست می‌دهد را تابع «خطی‌سازی» می‌نامیم. عنصر اول خروجی سر آن و باقی اعضا را دم آن می‌نامیم. تایع خطی سازی را به صورت زیر تعریف می‌کنیم:
(تابع خطی‌سازی کلاس
C 
را محاسبه می‌کنیم در حالی که از کلاس‌های 
B1, ..., BN
ارث‌بری می کند.)

L[C] = C + merge(L[B1], L[B2], ..., L[BN], B1, B2, ..., BN)

حال کافیست تا تابع 
merge
را تعریف کنیم.

تابع 
merge
به این صورت کار می‌کند که از سر 
L[B1]
شروع می کند و در صورتی که سر آن در دم هیچ یک از دیگر لیست های ورودی تابع نباشد آن را از سر آن حذف  کرده و به انتهای لیست خروجی برای خطی‌سازی 
C  
اضافه می‌کند. اما در صورتی که سر آن در دم لیست دیگری یافت شود به سراغ لیست دیگر می‌رود.
این روند تا زمانی ادامه پیدا می‌کند که همه کلاس‌ها تمام شود یا دیگر نتوانیم ادامه دهیم.
اگر به جایی برسیم که نتوانیم ادامه دهیم پایتون با نشان دادن خطایی از به وجود آمدن کلاس مورد نظر جلوگیری می‌کند.

### مثالی از این‌که نتوانیم کلاس را تشکیل دهیم

کد زیر را در نظر بگیرید:
```markdown
>>> O = object
>>> class Y(O): pass
>>> class X(O): pass
>>> class B(X,Y): pass
>>> class A(X,Y): pass
>>> class C(A,B): pass
```

در نتیجه:
```markdown
L[O] = 0
L[X] = X O
L[Y] = Y O
L[A] = A X Y O
L[B] = B Y X O
```
حال مقدار
L[C]
را محاسبه می‌کنیم:

```markdown
L[C] = C + merge(AXYO, BYXO, AB)
     = C + A + merge(XYO, BYXO, B)
     = C + A + B + merge(XYO, YXO)
```

 همانطور که ملاحظه می‌شود
 X 
 که سر لیست اول است در دم لیست بعدی و 
 Y 
 که در لیست دوم است در دم لیست دیگر قرار دارد و به بن‌بست رسیدیم.
 لذا دیگر نمی‌توانیم ادامه دهیم.
و پایتون اجازه تشکیل کلاس را نمی‌دهد.
### منابع

[Makina](https://makina-corpus.com/blog/metier/2014/python-tutorial-understanding-python-mro-class-search-path)
[Python Docs](https://www.python.org/download/releases/2.3/mro/)

